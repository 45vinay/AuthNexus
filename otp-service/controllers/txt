// server.js
// import { db } from "../models/otpModel";
// require("dotenv").config();
// const express = require("express");
// const connectToDb  = require("./database/db");
// const otpRoutes = require("./routes/otpRoutes");

// const app = express();
// const PORT = process.env.PORT || 6000;

// // Middleware
// app.use(express.json());
// app.use((req, res, next) => {
//   console.log(`[${new Date().toISOString()}] ${req.method} ${req.originalUrl}`);
//   next(); // move to next handler
// });

// // Database connection
// connectToDb();

// // Routes
// app.use("/api/otp", otpRoutes);

// // Start server
// app.listen(PORT, () => console.log(`üöÄ OTP Service running on port ${PORT}`));

// db.js
// const mongoose = require("mongoose");

// const connectToDb = async () => {
//   try {
//     await mongoose.connect(process.env.MONGO_URI, {
//       useNewUrlParser: true,
//       useUnifiedTopology: true,
//     });
//     console.log("‚úÖ Connected to OTP Database");
//   } catch (err) {
//     console.error("‚ùå OTP DB Connection Error:", err.message);
//     process.exit(1);
//   }
// };

// module.exports = connectToDb;

// otpModel.js
// const mongoose = require("mongoose");

// const otpSchema = new mongoose.Schema({
//   email: { type: String, required: true },
//   otpHash: { type: String, required: true },
//   purpose: { type: String, required: true },
//   verificationToken: { type: String, required: true },
//   expiresAt: { type: Date, required: true },
//   verified: { type: Boolean, default: false }
// }, { timestamps: true });

// const Otp = mongoose.model("Otp", otpSchema);
// module.exports = Otp;

// otpRoutes.js
// const express = require("express");
// const router = express.Router();
// const { sendOtp, verifyOtp } = require("../controllers/otpControllers");

// router.post("/send", sendOtp);
// router.post("/verify", verifyOtp);

// module.exports = router;

// SendmailTransport.js
// const nodemailer = require("nodemailer");

// const transporter = nodemailer.createTransport({
//   service: "gmail",
//   auth: {
//     user: process.env.EMAIL_USER,
//     pass: process.env.EMAIL_PASS
//   }
// });

// async function sendOtpEmail(to, otp) {
//   const mailOptions = {
//     from: process.env.EMAIL_USER,
//     to,
//     subject: "Your OTP Code",
//     text: `Your OTP is ${otp}. It expires in 5 minutes.`
//   };

//   await transporter.sendMail(mailOptions);
// }

// module.exports = sendOtpEmail;


// otpController.js
// // controllers/otp-controller.js
// const Otp = require('../models/otpModel'); // Assuming this is correct
// const nodemailer = require('nodemailer');
// const crypto = require('crypto');
// const bcrypt = require("bcryptjs");

// // ‚úÖ Configure Gmail SMTP (Should be in a separate config/utility file for best practice)
// const transporter = nodemailer.createTransport({
//   host: "smtp.gmail.com",
//   port: 465,
//   secure: true,
//   auth: {
//     user: process.env.EMAIL_USER,
//     pass: process.env.EMAIL_PASS,
//   },
// });

// // Verify transporter
// transporter.verify((error, success) => {
//   if (error) console.error("‚ùå Email transporter error:", error);
//   else console.log("‚úÖ Email transporter ready");
// });


// // üì© Send OTP
// exports.sendOtp = async (req, res) => {
//   try {
//     const { email, purpose } = req.body;
//     if (!email || !purpose) {
//       return res.status(400).json({ success: false, message: "Email and purpose are required" });
//     }

//     // 1Ô∏è‚É£ Generate and hash OTP
//     const otp = Math.floor(100000 + Math.random() * 900000).toString();
//     const otpHash = await bcrypt.hash(otp, 10);
//     const expiresAt = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes

//     // 2Ô∏è‚É£ Use findOneAndUpdate to replace any existing OTP for this email/purpose
//     // This handles the case where a user requests a new OTP before the old one expires.
//     const otpDoc = await Otp.findOneAndUpdate(
//         { email, purpose }, // Find by email AND purpose
//         { 
//             otpHash, 
//             expiresAt,
//             // üêõ REMOVED verificationToken field as it is unused in the current verification flow
//         },
//         { upsert: true, new: true, setDefaultsOnInsert: true } // Create if not exists, return new doc
//     );

//     // 3Ô∏è‚É£ Send OTP email
//     await transporter.sendMail({
//       from: process.env.EMAIL_USER,
//       to: email,
//       subject: `Your OTP for ${purpose}`,
//       text: `Your OTP is ${otp}. It will expire in 5 minutes.`,
//     });

//     console.log(`‚úÖ OTP sent for ${purpose} to ${email}`);

//     // 4Ô∏è‚É£ Simplified response (removed misleading verificationLink)
//     return res.status(200).json({
//       success: true,
//       message: "OTP sent successfully to your email. Check your inbox."
//     });

//   } catch (err) {
//     console.error("‚ùå Error sending OTP:", err);
//     return res.status(500).json({
//       success: false,
//       message: "Error sending OTP",
//       error: err.message,
//     });
//   }
// };

// // üîç Verify OTP
// exports.verifyOtp = async (req, res) => {
//   try {
//     const { email, otp, purpose } = req.body; // üî¥ CRITICAL FIX: Added 'purpose'
//     if (!email || !otp || !purpose) // üî¥ CRITICAL FIX: Required 'purpose'
//       return res.status(400).json({ success: false, message: 'Email, OTP, and purpose required' });

//     // 1Ô∏è‚É£ Find the OTP record for the specific email AND purpose
//     // üî¥ CRITICAL FIX: Query by purpose
//     const otpRecord = await Otp.findOne({ email, purpose });
    
//     if (!otpRecord)
//       return res.status(400).json({ success: false, message: 'Invalid, expired, or incorrect purpose for OTP' });

//     // 2Ô∏è‚É£ Check expiration
//     if (otpRecord.expiresAt < new Date()) {
//       await Otp.deleteOne({ _id: otpRecord._id });
//       return res.status(400).json({ success: false, message: 'OTP expired' });
//     }

//     // 3Ô∏è‚É£ Compare plain OTP with hashed OTP
//     const isMatch = await bcrypt.compare(otp, otpRecord.otpHash);
//     if (!isMatch)
//       return res.status(400).json({ success: false, message: 'Incorrect OTP' });

//     // 4Ô∏è‚É£ Delete OTP after successful verification
//     await Otp.deleteOne({ _id: otpRecord._id });

//     return res.status(200).json({
//       success: true,
//       message: 'OTP verified successfully'
//     });

//   } catch (err) {
//     console.error('‚ùå Error verifying OTP:', err);
//     return res.status(500).json({
//       success: false,
//       message: 'Verification failed',
//       error: err.message
//     });
//   }
// };

// const verifyRegisterOtp = async (req, res) => {
//   const { username, email, password, otp } = req.body;
//   const logger = GetUserLogger(username || 'unknown');
//   const conn = getUserDb();
//   const User = createUserModel(conn);

//   try {
//     // üîπ Verify OTP with microservice
//     const verifyResponse = await axios.post(`${OTP_SERVICE_URL}/verify`, { email, otp,  purpose: "registration"});
//     if (!verifyResponse.data.success) {
//       return res.status(400).json({ success: false, message: 'Invalid or expired OTP' });
//     }

//     const hashedPassword = await bcrypt.hash(password, 10);
//     const newUser = new User({ username, email, password: hashedPassword });
//     await newUser.save();

//     await logToDB({ username, action: 'REGISTER_SUCCESS', message: 'User registered successfully', req });
//     logger.info('User registered successfully');

//     return res.status(201).json({ success: true, message: 'User registered successfully' });
//   } catch (err) {
//     logger.error('Error verifying OTP: ' + err.message);
//     return res.status(500).json({ success: false, message: 'OTP verification failed', error: err.message });
//   }
// };